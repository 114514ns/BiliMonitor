package main

import (
	"bytes"
	"compress/flate"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"math"
	mathRand "math/rand"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
	"golang.org/x/net/html"
)

type JsonType struct {
	s     string
	i     int
	i64   int64
	f32   float32
	f64   float64
	array []interface{}
	v     bool
	m     map[string]interface{}
}

func substr(input string, start int, length int) string {
	asRunes := []rune(input)

	if start >= len(asRunes) {
		return ""
	}

	if start+length > len(asRunes) {
		length = len(asRunes) - start
	}

	return string(asRunes[start : start+length])
}
func formatTime(input string) string {
	if input == "0000-00-00 00:00:00" {
		return "Invalid Date"
	}

	// Define layout compatible with the input
	layout := "2006-01-02 15:04:05"
	t, err := time.Parse(layout, input)
	if err != nil {
		fmt.Println("Error parsing date:", err)
		return "Parsing Error"
	}
	return t.Format(layout)
}
func Last(dir string) (fileName string, modTime time.Time, err error) {
	dirEntries, err := os.ReadDir(dir)
	if err != nil {
		return "", time.Time{}, err
	}

	var onlyFlvFiles []os.DirEntry
	for _, entry := range dirEntries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".flv") {
			onlyFlvFiles = append(onlyFlvFiles, entry)
		}
	}
	if len(onlyFlvFiles) == 0 {
		return "", time.Time{}, fmt.Errorf("no .flv files found in the directory: %s", dir)
	}

	sort.Slice(onlyFlvFiles, func(i, j int) bool {
		infoI, _ := onlyFlvFiles[i].Info()
		infoJ, _ := onlyFlvFiles[j].Info()
		return infoI.ModTime().After(infoJ.ModTime())
	})
	latestFile := onlyFlvFiles[0]
	info, err := latestFile.Info()
	if err != nil {
		return "", time.Time{}, err
	}
	return latestFile.Name(), info.ModTime(), nil
}
func FormatDuration(seconds int) string {
	duration := time.Duration(seconds) * time.Second
	hours := duration / time.Hour
	minutes := (duration % time.Hour) / time.Minute
	secs := (duration % time.Minute) / time.Second

	if hours > 0 {
		return fmt.Sprintf("%d:%02d:%02d", hours, minutes, secs)
	}
	return fmt.Sprintf("%d:%02d", minutes, secs)
}
func abs(a int) int {
	if a < 0 {
		return -a
	} else {
		return a
	}
}
func toInt64(s string) int64 {
	i64, _ := strconv.ParseInt(s, 10, 64)
	return i64
}
func toInt(s string) int {
	i64, _ := strconv.ParseInt(s, 10, 64)
	return int(i64)
}
func toFloat64(s string) float64 {
	i64, _ := strconv.ParseFloat(s, 64)
	return (i64)
}
func AppendElement[T any](queue []T, maxSize int, element T) []T {
	if len(queue) >= maxSize {
		queue = queue[1:]
	}
	return append(queue, element)
}
func DeepCopy[T any](src T) (T, error) {
	var dst T
	data, err := json.Marshal(src)
	if err != nil {
		return dst, err
	}
	err = json.Unmarshal(data, &dst)
	return dst, err
}
func getCorrespondPath(ts int64) string {
	const publicKeyPEM = `
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDLgd2OAkcGVtoE3ThUREbio0Eg
Uc/prcajMKXvkCKFCWhJYJcLkcM2DKKcSeFpD/j6Boy538YXnR6VhcuUJOhH2x71
nzPjfdTcqMz7djHum0qSZA0AyCBDABUqCrfNgCiJ00Ra7GmRj+YCK1NJEuewlb40
JNrRuoEUXpabUzGB8QIDAQAB
-----END PUBLIC KEY-----
`
	pubKeyBlock, _ := pem.Decode([]byte(publicKeyPEM))
	hash := sha256.New()
	random := rand.Reader
	msg := []byte(fmt.Sprintf("refresh_%d", ts))
	var pub *rsa.PublicKey
	pubInterface, parseErr := x509.ParsePKIXPublicKey(pubKeyBlock.Bytes)
	if parseErr != nil {
		return ""
	}
	pub = pubInterface.(*rsa.PublicKey)
	encryptedData, encryptErr := rsa.EncryptOAEP(hash, random, pub, msg, nil)
	if encryptErr != nil {
		return ""
	}
	return hex.EncodeToString(encryptedData)
}

func Index(s string, index int) string {
	runes := bytes.Runes([]byte(s))
	for i, rune := range runes {
		if i == int(index) {
			return string(rune)
		}
	}
	return ""
}
func extractTextFromHTML(htmlStr string) string {
	doc, _ := html.Parse(strings.NewReader(htmlStr))

	var f func(*html.Node) string
	f = func(n *html.Node) string {
		if n.Type == html.TextNode {
			return n.Data
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			text := f(c)
			if text != "" {
				return text
			}
		}
		return ""
	}

	return f(doc)
}
func Has[T comparable](a []T, b T) bool {
	for _, s := range a {
		if b == s {
			return true
		}
	}
	return false
}
func remove[T comparable](slice []T, value T) []T {
	for i, v := range slice {
		if v == value {
			return append(slice[:i], slice[i+1:]...)
		}
	}
	return slice
}
func chunkSlice[T any](slice []T, size int) [][]T {
	if size <= 0 {
		return nil
	}
	var chunks [][]T
	for i := 0; i < len(slice); i += size {
		end := i + size
		if end > len(slice) {
			end = len(slice)
		}
		chunks = append(chunks, slice[i:end])
	}
	return chunks
}
func checkIP(c *resty.Client) string {
	res, _ := c.R().SetHeader("Connection", "close").Get("https://api.bilibili.com/x/web-interface/zone")
	return res.String()
}
func RandomPick[T any](arr []T) T {
	if len(arr) == 0 {
		var zero T
		return zero // 如果数组为空，返回零值
	}
	mathRand.Seed(time.Now().UnixNano()) // 初始化随机种子
	index := mathRand.Intn(len(arr))
	return arr[index]
}

func getInt(obj interface{}, path string) int {
	return getObject(obj, path, "int").i
}
func getInt64(obj interface{}, path string) int64 {
	return getObject(obj, path, "int64").i64
}
func getString(obj interface{}, path string) string {
	return getObject(obj, path, "string").s
}
func getArray(obj interface{}, path string) []interface{} {
	return getObject(obj, path, "array").array
}
func getBool(obj interface{}, path string) bool {
	return getObject(obj, path, "bool").v
}
func getObject(obj interface{}, path string, typo string) JsonType {
	var array = strings.Split(path, ".")
	inner, ok := obj.(map[string]interface{})
	if !ok {
		return JsonType{}
	}
	var st = JsonType{}
	for i, s := range array {
		if i == len(array)-1 {

			value := inner[s]
			if value != nil {
				var t = reflect.TypeOf(value)
				if t.Kind() == reflect.String {
					st.s = value.(string)
				}
				if t.Kind() == reflect.Int {
					st.i, _ = value.(int)
				}
				if t.Kind() == reflect.Int64 {
					if value.(int64) > math.MaxInt {
						st.i64 = value.(int64)
					} else {
						st.i = value.(int)
					}

				}
				if t.Kind() == reflect.Float64 {
					if typo == "int" {
						st.i = int(value.(float64))
					}
					if typo == "int64" {
						st.i64 = int64(value.(float64))
					}
				}
				if t.Kind() == reflect.Slice {
					if typo == "array" {
						st.array = value.([]interface{})
					}
				}
				if t.Kind() == reflect.Bool {
					st.v = value.(bool)
				}
				if t.Kind() == reflect.Map {
					st.m = value.(map[string]interface{})
				}
			}

			return st
		} else {

			if inner[s] == nil {
				return st
			}
			inner = inner[s].(map[string]interface{})
		}
	}
	return st
}
func toString(i int64) string {
	return strconv.FormatInt(i, 10)
}

func getColor(level int) string {
	if level <= 10 {
		return "#727BB5"
	}
	if level <= 20 {
		return "#CF86B2"
	}
	if level <= 30 {
		return "#5EC0F7"
	}
	if level <= 40 {
		return "#6992FF"
	}
	if level <= 50 {
		return "#AA78F1"
	}
	if level <= 60 {
		return "#ED5674"
	}
	if level <= 70 {
		return "#F58737"
	}
	if level <= 80 {
		return "#F58837"
	}
	if level <= 90 {
		return "#F58837"
	}

	return ""

}

func DeflateDecompress(data []byte) ([]byte, error) {
	r := flate.NewReader(bytes.NewReader(data))
	defer r.Close()

	var out bytes.Buffer
	_, err := io.Copy(&out, r)
	if err != nil {
		return nil, err
	}
	return out.Bytes(), nil
}

var INTERACT_WORD_PB = []uint8{ //https://web.archive.org/web/20251212084412/https://github.com/SocialSisterYi/bilibili-API-collect/issues/1332
	// Offset 0x00000000 to 0x000003D1
	0x0A, 0xCF, 0x07, 0x0A, 0x0A, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0x70, 0x72,
	0x6F, 0x74, 0x6F, 0x22, 0xB8, 0x07, 0x0A, 0x0E, 0x49, 0x6E, 0x74, 0x65,
	0x72, 0x61, 0x63, 0x74, 0x57, 0x6F, 0x72, 0x64, 0x56, 0x32, 0x12, 0x10,
	0x0A, 0x03, 0x75, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x03, 0x75, 0x69, 0x64, 0x12, 0x14, 0x0A, 0x05, 0x75, 0x6E, 0x61, 0x6D,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x75, 0x6E, 0x61,
	0x6D, 0x65, 0x12, 0x32, 0x0A, 0x08, 0x6D, 0x73, 0x67, 0x5F, 0x74, 0x79,
	0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0E, 0x32, 0x17, 0x2E, 0x49,
	0x6E, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x57, 0x6F, 0x72, 0x64, 0x56,
	0x32, 0x2E, 0x4D, 0x73, 0x67, 0x54, 0x79, 0x70, 0x65, 0x52, 0x07, 0x6D,
	0x73, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12, 0x17, 0x0A, 0x07, 0x72, 0x6F,
	0x6F, 0x6D, 0x5F, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0D, 0x52,
	0x06, 0x72, 0x6F, 0x6F, 0x6D, 0x49, 0x64, 0x12, 0x1C, 0x0A, 0x09, 0x74,
	0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x0D, 0x52, 0x09, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D,
	0x70, 0x12, 0x14, 0x0A, 0x05, 0x73, 0x63, 0x6F, 0x72, 0x65, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x73, 0x63, 0x6F, 0x72, 0x65, 0x12,
	0x3D, 0x0A, 0x0A, 0x66, 0x61, 0x6E, 0x73, 0x5F, 0x6D, 0x65, 0x64, 0x61,
	0x6C, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0B, 0x32, 0x19, 0x2E, 0x49, 0x6E,
	0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x57, 0x6F, 0x72, 0x64, 0x56, 0x32,
	0x2E, 0x46, 0x61, 0x6E, 0x73, 0x4D, 0x65, 0x64, 0x61, 0x6C, 0x48, 0x00,
	0x52, 0x09, 0x66, 0x61, 0x6E, 0x73, 0x4D, 0x65, 0x64, 0x61, 0x6C, 0x88,
	0x01, 0x01, 0x12, 0x35, 0x0A, 0x09, 0x72, 0x61, 0x6E, 0x6B, 0x5F, 0x69,
	0x6E, 0x66, 0x6F, 0x18, 0x0C, 0x20, 0x01, 0x28, 0x0B, 0x32, 0x18, 0x2E,
	0x49, 0x6E, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x57, 0x6F, 0x72, 0x64,
	0x56, 0x32, 0x2E, 0x52, 0x61, 0x6E, 0x6B, 0x49, 0x6E, 0x66, 0x6F, 0x52,
	0x08, 0x72, 0x61, 0x6E, 0x6B, 0x49, 0x6E, 0x66, 0x6F, 0x12, 0x21, 0x0A,
	0x0C, 0x74, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x5F, 0x74, 0x69, 0x6D,
	0x65, 0x18, 0x0F, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0B, 0x74, 0x72, 0x69,
	0x67, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6D, 0x65, 0x12, 0x24, 0x0A, 0x0B,
	0x67, 0x75, 0x61, 0x72, 0x64, 0x5F, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x18,
	0x10, 0x20, 0x01, 0x28, 0x0D, 0x48, 0x01, 0x52, 0x0A, 0x67, 0x75, 0x61,
	0x72, 0x64, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x88, 0x01, 0x01, 0x12, 0x22,
	0x0A, 0x0A, 0x64, 0x61, 0x69, 0x6C, 0x79, 0x5F, 0x72, 0x61, 0x6E, 0x6B,
	0x18, 0x11, 0x20, 0x01, 0x28, 0x0D, 0x48, 0x02, 0x52, 0x09, 0x64, 0x61,
	0x69, 0x6C, 0x79, 0x52, 0x61, 0x6E, 0x6B, 0x88, 0x01, 0x01, 0x1A, 0xF7,
	0x02, 0x0A, 0x09, 0x46, 0x61, 0x6E, 0x73, 0x4D, 0x65, 0x64, 0x61, 0x6C,
	0x12, 0x1B, 0x0A, 0x09, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5F, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x74, 0x61, 0x72,
	0x67, 0x65, 0x74, 0x49, 0x64, 0x12, 0x1F, 0x0A, 0x0B, 0x6D, 0x65, 0x64,
	0x61, 0x6C, 0x5F, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0D, 0x52, 0x0A, 0x6D, 0x65, 0x64, 0x61, 0x6C, 0x4C, 0x65, 0x76,
	0x65, 0x6C, 0x12, 0x1D, 0x0A, 0x0A, 0x6D, 0x65, 0x64, 0x61, 0x6C, 0x5F,
	0x6E, 0x61, 0x6D, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x6D, 0x65, 0x64, 0x61, 0x6C, 0x4E, 0x61, 0x6D, 0x65, 0x12, 0x14, 0x0A,
	0x05, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0D,
	0x52, 0x05, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x12, 0x1F, 0x0A, 0x0B, 0x63,
	0x6F, 0x6C, 0x6F, 0x72, 0x5F, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0D, 0x52, 0x0A, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x53,
	0x74, 0x61, 0x72, 0x74, 0x12, 0x1B, 0x0A, 0x09, 0x63, 0x6F, 0x6C, 0x6F,
	0x72, 0x5F, 0x65, 0x6E, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0D, 0x52,
	0x08, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x45, 0x6E, 0x64, 0x12, 0x21, 0x0A,
	0x0C, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x5F, 0x62, 0x6F, 0x72, 0x64, 0x65,
	0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0D, 0x52, 0x0B, 0x63, 0x6F, 0x6C,
	0x6F, 0x72, 0x42, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x12, 0x22, 0x0A, 0x0A,
	0x69, 0x73, 0x5F, 0x6C, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0D, 0x48, 0x00, 0x52, 0x09, 0x69, 0x73, 0x4C, 0x69,
	0x67, 0x68, 0x74, 0x65, 0x64, 0x88, 0x01, 0x01, 0x12, 0x24, 0x0A, 0x0B,
	0x67, 0x75, 0x61, 0x72, 0x64, 0x5F, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x0D, 0x48, 0x01, 0x52, 0x0A, 0x67, 0x75, 0x61,
	0x72, 0x64, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x88, 0x01, 0x01, 0x12, 0x17,
	0x0A, 0x07, 0x72, 0x6F, 0x6F, 0x6D, 0x5F, 0x69, 0x64, 0x18, 0x0C, 0x20,
	0x01, 0x28, 0x0D, 0x52, 0x06, 0x72, 0x6F, 0x6F, 0x6D, 0x49, 0x64, 0x12,
	0x14, 0x0A, 0x05, 0x73, 0x63, 0x6F, 0x72, 0x65, 0x18, 0x0D, 0x20, 0x01,
	0x28, 0x0D, 0x52, 0x05, 0x73, 0x63, 0x6F, 0x72, 0x65, 0x42, 0x0D, 0x0A,
	0x0B, 0x5F, 0x69, 0x73, 0x5F, 0x6C, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64,
	0x42, 0x0E, 0x0A, 0x0C, 0x5F, 0x67, 0x75, 0x61, 0x72, 0x64, 0x5F, 0x6C,
	0x65, 0x76, 0x65, 0x6C, 0x1A, 0x1E, 0x0A, 0x08, 0x52, 0x61, 0x6E, 0x6B,
	0x49, 0x6E, 0x66, 0x6F, 0x12, 0x12, 0x0A, 0x04, 0x72, 0x61, 0x6E, 0x6B,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0D, 0x52, 0x04, 0x72, 0x61, 0x6E, 0x6B,
	0x22, 0x52, 0x0A, 0x07, 0x4D, 0x73, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12,
	0x0F, 0x0A, 0x0B, 0x4D, 0x53, 0x47, 0x5F, 0x55, 0x4E, 0x4B, 0x4E, 0x4F,
	0x57, 0x4E, 0x10, 0x00, 0x12, 0x12, 0x0A, 0x0E, 0x4D, 0x53, 0x47, 0x5F,
	0x45, 0x4E, 0x54, 0x45, 0x52, 0x5F, 0x52, 0x4F, 0x4F, 0x4D, 0x10, 0x01,
	0x12, 0x0E, 0x0A, 0x0A, 0x4D, 0x53, 0x47, 0x5F, 0x46, 0x4F, 0x4C, 0x4C,
	0x4F, 0x57, 0x10, 0x02, 0x12, 0x12, 0x0A, 0x0E, 0x4D, 0x53, 0x47, 0x5F,
	0x53, 0x48, 0x41, 0x52, 0x45, 0x5F, 0x52, 0x4F, 0x4F, 0x4D, 0x10, 0x03,
	0x42, 0x0D, 0x0A, 0x0B, 0x5F, 0x66, 0x61, 0x6E, 0x73, 0x5F, 0x6D, 0x65,
	0x64, 0x61, 0x6C, 0x42, 0x0E, 0x0A, 0x0C, 0x5F, 0x67, 0x75, 0x61, 0x72,
	0x64, 0x5F, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x42, 0x0D, 0x0A, 0x0B, 0x5F,
	0x64, 0x61, 0x69, 0x6C, 0x79, 0x5F, 0x72, 0x61, 0x6E, 0x6B, 0x62, 0x06,
	0x70, 0x72, 0x6F, 0x74, 0x6F, 0x33}
